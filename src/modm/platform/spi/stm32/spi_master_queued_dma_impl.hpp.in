/*
 * Copyright (c) 2020, Mike Wolfram
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

#ifndef MODM_STM32_SPI_MASTER{{ id }}_QUEUED_DMA_HPP
#	error 	"Don't include this file directly, use 'spi_master_{{ id }}__Queued_Dma.hpp' instead!"
#endif

template <class DmaChannelRx, class DmaChannelTx, size_t QUEUE_SIZE, size_t SPI_DATA_BUFFER_COUNT, size_t SPI_DATA_BUFFER_LENGTH>
template <class SystemClock, modm::baudrate_t baudrate, modm::percent_t tolerance>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx, QUEUE_SIZE, SPI_DATA_BUFFER_COUNT, SPI_DATA_BUFFER_LENGTH>::initialize()
{
	// Configure the DMA channels, then calls SpiMaster{{ id }}::initialzie().
	Dma::RxChannel::configure(DmaBase::DataTransferDirection::PeripheralToMemory,
			DmaBase::MemoryDataSize::Byte, DmaBase::PeripheralDataSize::Byte,
			DmaBase::MemoryIncrementMode::Increment, DmaBase::PeripheralIncrementMode::Fixed,
			DmaBase::Priority::High);
	Dma::RxChannel::setPeripheralAddress(SPI{{ id }}_BASE + 0x0c);
	Dma::RxChannel::setTransferErrorIrqHandler(handleDmaTransferError);
	Dma::RxChannel::setTransferCompleteIrqHandler(handleDmaReceiveComplete);
	Dma::RxChannel::enableInterruptVector();
	Dma::RxChannel::enableInterrupt(DmaBase::InterruptEnable::TransferError |
			DmaBase::InterruptEnable::TransferComplete);
	Dma::RxChannel::template setPeripheralRequest<Dma::RxRequest>();

	Dma::TxChannel::configure(DmaBase::DataTransferDirection::MemoryToPeripheral,
			DmaBase::MemoryDataSize::Byte, DmaBase::PeripheralDataSize::Byte,
			DmaBase::MemoryIncrementMode::Increment, DmaBase::PeripheralIncrementMode::Fixed,
			DmaBase::Priority::High);
	Dma::TxChannel::setPeripheralAddress(SPI{{ id }}_BASE + 0x0c);
	Dma::TxChannel::setTransferErrorIrqHandler(handleDmaTransferError);
	Dma::TxChannel::setTransferCompleteIrqHandler(handleDmaTransmitComplete);
	Dma::TxChannel::enableInterruptVector();
	Dma::TxChannel::enableInterrupt(DmaBase::InterruptEnable::TransferError |
			DmaBase::InterruptEnable::TransferComplete);
	Dma::TxChannel::template setPeripheralRequest<Dma::TxRequest>();

	SpiMaster{{ id }}::initialize<SystemClock, baudrate, tolerance>();

%% if "fifo" in features
	SpiHal{{ id }}::setRxFifoThreshold(SpiHal{{ id }}::RxFifoThreshold::QuarterFull);
%% endif
}

template <class DmaChannelRx, class DmaChannelTx, size_t QUEUE_SIZE, size_t SPI_DATA_BUFFER_COUNT, size_t SPI_DATA_BUFFER_LENGTH>
uint8_t
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx, QUEUE_SIZE, SPI_DATA_BUFFER_COUNT, SPI_DATA_BUFFER_LENGTH>::transferBlockingSingleByte(uint8_t data){
	// disable DMA for single byte transfer
	SpiHal{{ id }}::disableInterrupt(SpiBase::Interrupt::TxDmaEnable | SpiBase::Interrupt::RxDmaEnable);
	// wait for previous transfer to finish
	while (!SpiHal{{ id }}::isTransmitRegisterEmpty()){
		/// ...
	}

	// start transfer by copying data into register
	SpiHal{{ id }}::write(data);
	while(!SpiHal{{ id }}::isReceiveRegisterNotEmpty()){
		/// ...
	}
	SpiHal{{ id }}::read(data);
	
	return data;
}

template <class DmaChannelRx, class DmaChannelTx, size_t QUEUE_SIZE, size_t SPI_DATA_BUFFER_COUNT, size_t SPI_DATA_BUFFER_LENGTH>
uint8_t
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx, QUEUE_SIZE , SPI_DATA_BUFFER_COUNT, SPI_DATA_BUFFER_LENGTH>::transferBlocking(uint8_t data,
		modm::SpiTransferConfiguration& configuration, 
		SpiTransferChipSelectBehavior&& csbehavior)
{
	if(configuration.pre){
		configuration.pre();
	}
	csbehavior.pre();
	uint8_t read = transferBlockingSingleByte(data);
	csbehavior.post();
	if(configuration.post){
		configuration.post();
	}
	return read;
}

template <class DmaChannelRx, class DmaChannelTx, size_t QUEUE_SIZE, size_t SPI_DATA_BUFFER_COUNT, size_t SPI_DATA_BUFFER_LENGTH>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx, QUEUE_SIZE , SPI_DATA_BUFFER_COUNT, SPI_DATA_BUFFER_LENGTH>::transferBlocking(const uint8_t *tx, uint8_t *rx, std::size_t length, 
		modm::SpiTransferConfiguration& configuration, 
		SpiTransferChipSelectBehavior&& csbehavior)
{
	if(configuration.pre){
		configuration.pre();
	}
	csbehavior.pre();
	for(size_t i = 0; i < length; i++){
		uint8_t b = tx[i];
		rx[i] = transferBlockingSingleByte(b);
	}
	csbehavior.post();
	if(configuration.post){
		configuration.post();
	}
}

template <class DmaChannelRx, class DmaChannelTx, size_t QUEUE_SIZE, size_t SPI_DATA_BUFFER_COUNT, size_t SPI_DATA_BUFFER_LENGTH>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx, QUEUE_SIZE , SPI_DATA_BUFFER_COUNT, SPI_DATA_BUFFER_LENGTH>::handleDmaTransferError()
{
	SpiHal{{ id }}::disableInterrupt(SpiBase::Interrupt::TxDmaEnable |
			SpiBase::Interrupt::RxDmaEnable);
	Dma::RxChannel::stop();
	Dma::TxChannel::stop();
	dmaError = true;
}

template <class DmaChannelRx, class DmaChannelTx, size_t QUEUE_SIZE, size_t SPI_DATA_BUFFER_COUNT, size_t SPI_DATA_BUFFER_LENGTH>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx, QUEUE_SIZE , SPI_DATA_BUFFER_COUNT, SPI_DATA_BUFFER_LENGTH>::handleDmaReceiveComplete()
{
	Dma::RxChannel::stop();
	dmaReceiveComplete = true;
	end();
}

template <class DmaChannelRx, class DmaChannelTx, size_t QUEUE_SIZE, size_t SPI_DATA_BUFFER_COUNT, size_t SPI_DATA_BUFFER_LENGTH>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx, QUEUE_SIZE , SPI_DATA_BUFFER_COUNT, SPI_DATA_BUFFER_LENGTH>::handleDmaTransmitComplete()
{
	Dma::TxChannel::stop();
	dmaTransmitComplete = true;
	end();
}

template <class DmaChannelRx, class DmaChannelTx, size_t QUEUE_SIZE, size_t SPI_DATA_BUFFER_COUNT, size_t SPI_DATA_BUFFER_LENGTH>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx, QUEUE_SIZE , SPI_DATA_BUFFER_COUNT, SPI_DATA_BUFFER_LENGTH>::end(bool skipPost)
{
	/// we finished a task thingy
	if(dmaTransmitComplete && dmaReceiveComplete){
		const auto& entry = queue.front();
		/// do we want to skip its post stuff?
		if(!skipPost){
			/// do its post stuff
			if(entry.step.configuration.post){
				entry.step.configuration.post();
			}
			/// call cs post behavor
			entry.step.cs.post();
			/// call step callback
			if(entry.step.cb){
				entry.step.cb();
			}
		}
		/// pop the task from queue
		queue.pop();
		/// re trgger ourselfs if necessary
		exec();
	}
}

template <class DmaChannelRx, class DmaChannelTx, size_t QUEUE_SIZE, size_t SPI_DATA_BUFFER_COUNT, size_t SPI_DATA_BUFFER_LENGTH>
modm::ResumableResult<uint8_t>
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx, QUEUE_SIZE , SPI_DATA_BUFFER_COUNT, SPI_DATA_BUFFER_LENGTH>::transfer(uint8_t data)
{
	// this is a manually implemented "fast resumable function"
	// there is no context or nesting protection, since we don't need it.
	// there are only two states encoded into 1 bit (LSB of state):
	//   1. waiting to start, and
	//   2. waiting to finish.
	// LSB != Bit0 ?
	if ( !(state & Bit0) )
	{
		// disable DMA for single byte transfer
		SpiHal{{ id }}::disableInterrupt(SpiBase::Interrupt::TxDmaEnable |
				SpiBase::Interrupt::RxDmaEnable);

		// wait for previous transfer to finish
		if (!SpiHal{{ id }}::isTransmitRegisterEmpty())
			return {modm::rf::Running};

		// start transfer by copying data into register
		SpiHal{{ id }}::write(data);

		// set LSB = Bit0
		state |= Bit0;
	}

	if (!SpiHal{{ id }}::isReceiveRegisterNotEmpty())
		return {modm::rf::Running};

	SpiHal{{ id }}::read(data);

	// transfer finished
	state &= ~Bit0;
	return {modm::rf::Stop, data};
}


template <class DmaChannelRx, class DmaChannelTx, size_t QUEUE_SIZE, size_t SPI_DATA_BUFFER_COUNT, size_t SPI_DATA_BUFFER_LENGTH>
modm::ResumableResult<void>
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx, QUEUE_SIZE , SPI_DATA_BUFFER_COUNT, SPI_DATA_BUFFER_LENGTH>::transfer(const uint8_t *tx, uint8_t *rx, std::size_t length)
{
	// this is a manually implemented "fast resumable function"
	// there is no context or nesting protection, since we don't need it.
	// there are only two states encoded into 1 bit (Bit1 of state):
	//   1. initialize index, and
	//   2. wait for 1-byte transfer to finish.

	// we are only interested in Bit1
	switch(state & Bit1)
	{
	case 0:
		// we will only visit this state once
		state |= Bit1;
		dmaError = false;
		SpiHal{{ id }}::enableInterrupt(SpiBase::Interrupt::TxDmaEnable |
				SpiBase::Interrupt::RxDmaEnable);

		if (tx) {
			Dma::TxChannel::setMemoryAddress(uint32_t(tx));
			Dma::TxChannel::setMemoryIncrementMode(true);
		} else {
			Dma::TxChannel::setMemoryAddress(uint32_t(&dmaDummy));
			Dma::TxChannel::setMemoryIncrementMode(false);
		}
		if (rx) {
			Dma::RxChannel::setMemoryAddress(uint32_t(rx));
			Dma::RxChannel::setMemoryIncrementMode(true);
		} else {
			Dma::RxChannel::setMemoryAddress(uint32_t(&dmaDummy));
			Dma::RxChannel::setMemoryIncrementMode(false);
		}

		Dma::RxChannel::setDataLength(length);
		dmaReceiveComplete = false;
		Dma::RxChannel::start();

		Dma::TxChannel::setDataLength(length);
		dmaTransmitComplete = false;
		Dma::TxChannel::start();

		[[fallthrough]];

	default:
		while (true) {
			if (dmaError)
				break;
			if (not dmaTransmitComplete and not dmaReceiveComplete)
				return { modm::rf::Running };
			if (SpiHal{{ id }}::getInterruptFlags() & SpiBase::InterruptFlag::Busy)
				return { modm::rf::Running };
%% if "fifo" in features
			if (SpiHal{{ id }}::getInterruptFlags() & SpiBase::InterruptFlag::FifoTxLevel)
				return { modm::rf::Running };
			if (SpiHal{{ id }}::getInterruptFlags() & SpiBase::InterruptFlag::FifoRxLevel)
				return { modm::rf::Running };
%% endif
			break;
		}

		SpiHal{{ id }}::disableInterrupt(SpiBase::Interrupt::TxDmaEnable |
				SpiBase::Interrupt::RxDmaEnable);
		// clear the state
		state &= ~Bit1;
		return {modm::rf::Stop};
	}
}

template <class DmaChannelRx, class DmaChannelTx, size_t QUEUE_SIZE, size_t SPI_DATA_BUFFER_COUNT, size_t SPI_DATA_BUFFER_LENGTH>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx, QUEUE_SIZE , SPI_DATA_BUFFER_COUNT, SPI_DATA_BUFFER_LENGTH>::basicTransfer(const uint8_t *tx, uint8_t *rx, std::size_t length)
{
	dmaError = false;
	SpiHal{{ id }}::enableInterrupt(SpiBase::Interrupt::TxDmaEnable | SpiBase::Interrupt::RxDmaEnable);
	if (tx) {
		Dma::TxChannel::setMemoryAddress(uint32_t(tx));
		Dma::TxChannel::setMemoryIncrementMode(true);
	} else {
		Dma::TxChannel::setMemoryAddress(uint32_t(&dmaDummy));
		Dma::TxChannel::setMemoryIncrementMode(false);
	}
	if (rx) {
		Dma::RxChannel::setMemoryAddress(uint32_t(rx));
		Dma::RxChannel::setMemoryIncrementMode(true);
	} else {
		Dma::RxChannel::setMemoryAddress(uint32_t(&dmaDummy));
		Dma::RxChannel::setMemoryIncrementMode(false);
	}

	Dma::RxChannel::setDataLength(length);
	dmaReceiveComplete = false;
	Dma::RxChannel::start();

	Dma::TxChannel::setDataLength(length);
	dmaTransmitComplete = false;
	Dma::TxChannel::start();
}


