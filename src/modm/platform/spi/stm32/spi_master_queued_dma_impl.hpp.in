/*
 * Copyright (c) 2020, Mike Wolfram
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

#ifndef MODM_STM32_SPI_MASTER{{ id }}_QUEUED_DMA_HPP
#	error 	"Don't include this file directly, use 'spi_master_{{ id }}__Queued_Dma.hpp' instead!"
#endif

template <class DmaChannelRx, class DmaChannelTx>
template <class SystemClock, modm::baudrate_t baudrate, modm::percent_t tolerance>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::initialize()
{
	// Configure the DMA channels, then calls SpiMaster{{ id }}::initialzie().
	Dma::RxChannel::configure(DmaBase::DataTransferDirection::PeripheralToMemory,
			DmaBase::MemoryDataSize::Byte, DmaBase::PeripheralDataSize::Byte,
			DmaBase::MemoryIncrementMode::Increment, DmaBase::PeripheralIncrementMode::Fixed,
			DmaBase::Priority::High);
	Dma::RxChannel::setPeripheralAddress(SPI{{ id }}_BASE + 0x0c);
	Dma::RxChannel::setTransferErrorIrqHandler(handleDmaTransferError);
	Dma::RxChannel::setTransferCompleteIrqHandler(handleDmaReceiveComplete);
	Dma::RxChannel::enableInterruptVector();
	Dma::RxChannel::enableInterrupt(DmaBase::InterruptEnable::TransferError |
			DmaBase::InterruptEnable::TransferComplete);
	Dma::RxChannel::template setPeripheralRequest<Dma::RxRequest>();

	Dma::TxChannel::configure(DmaBase::DataTransferDirection::MemoryToPeripheral,
			DmaBase::MemoryDataSize::Byte, DmaBase::PeripheralDataSize::Byte,
			DmaBase::MemoryIncrementMode::Increment, DmaBase::PeripheralIncrementMode::Fixed,
			DmaBase::Priority::High);
	Dma::TxChannel::setPeripheralAddress(SPI{{ id }}_BASE + 0x0c);
	Dma::TxChannel::setTransferErrorIrqHandler(handleDmaTransferError);
	Dma::TxChannel::setTransferCompleteIrqHandler(handleDmaTransmitComplete);
	Dma::TxChannel::enableInterruptVector();
	Dma::TxChannel::enableInterrupt(DmaBase::InterruptEnable::TransferError |
			DmaBase::InterruptEnable::TransferComplete);
	Dma::TxChannel::template setPeripheralRequest<Dma::TxRequest>();

	SpiMaster{{ id }}::initialize<SystemClock, baudrate, tolerance>();

%% if "fifo" in features
	SpiHal{{ id }}::setRxFifoThreshold(SpiHal{{ id }}::RxFifoThreshold::QuarterFull);
%% endif
}

template <class DmaChannelRx, class DmaChannelTx>
uint8_t
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::transferBlockingSingleByte(uint8_t data){
	// disable DMA for single byte transfer
	SpiHal{{ id }}::disableInterrupt(SpiBase::Interrupt::TxDmaEnable | SpiBase::Interrupt::RxDmaEnable);
	// wait for previous transfer to finish
	while (!SpiHal{{ id }}::isTransmitRegisterEmpty()){
		/// ...
	}
	// start transfer by copying data into register
	SpiHal{{ id }}::write(data);
	while(!SpiHal{{ id }}::isReceiveRegisterNotEmpty()){
		/// ...
	}
	SpiHal{{ id }}::read(data);
	return data;
}

template <class DmaChannelRx, class DmaChannelTx>
uint8_t
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::transferBlocking(uint8_t data, modm::SpiTransferConfiguration& configuration)
{
	if(configuration.pre.is_valid()){
		configuration.pre();
	}
	uint8_t read = transferBlockingSingleByte(data);
	if(configuration.post.is_valid()){
		configuration.post();
	}
	return read;
}

template <class DmaChannelRx, class DmaChannelTx>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::transferBlocking(const uint8_t *tx, uint8_t *rx, std::size_t length, modm::SpiTransferConfiguration& configuration){
	if(configuration.pre.is_valid()){
		configuration.pre();
	}
	for(size_t i = 0; i < length; i++){
		uint8_t b = tx[i];
		rx[i] = transferBlockingSingleByte(b);
	}
	if(configuration.post.is_valid()){
		configuration.post();
	}
}

template <class DmaChannelRx, class DmaChannelTx>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::transferBegin(const uint8_t *tx,
		uint8_t *rx, std::size_t length, modm::SpiTransferCallback cb, modm::SpiTransferConfiguration& configuration)
{
	if(length > SPI_DATA_BUFFER_LENGTH){
		return;
	}
	const uint8_t* buf = buffers.at(nextBuffer).data();
	std::memcpy(buf, tx, length);
	// ---------------------------
	auto task = createTask(buf, rx, length, {}, configuration);
	queue.push({.task = task, .cb = cb, .config = configuration });
	// ---------------------------
	queue.push({.task = task, .cb = cb, .config = configuration });
	nextBuffer++;
	if(nextBuffer >= SPI_DATA_BUFFER_COUNT){
		nextBuffer = 0;
	}
}


template <class DmaChannelRx, class DmaChannelTx>
template <typename Length>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::transferNext(const uint8_t *tx,
		uint8_t *rx, Length length, modm::SpiTransferCallback cb, modm::SpiTransferConfiguration& configuration)
{
	auto task = createTask(tx, rx, length, {}, configuration);
	queue.push({.task = task, .cb = cb, .config = configuration });
}

template <class DmaChannelRx, class DmaChannelTx>
template <typename Length>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::transferNext(const uint8_t *tx,
		uint8_t *rx, Length length, modm::SpiTransferCallback cb, 
		modm::SpiTransferConditional condition, modm::SpiTransferConfiguration& configuration)
{
	auto task = createTask(tx, rx, length, condition, configuration);
	queue.push({.task = task, .cb = cb, .config = configuration });
}


template <class DmaChannelRx, class DmaChannelTx>
template <typename Length>
modm::SpiTransferTask modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::createTask(
		const uint8_t *tx, uint8_t *rx, Length length, modm::SpiTransferCallback cb, 
		modm::SpiTransferConditional condition, modm::SpiTransferConfiguration& configuration)
{
	return [tx, rx, length, condition, configuration](){
		bool work = true;
		if(condition.is_valid()){
			work = condition();
		}
		if(work){
			/// define length
			size_t l = 0;
			if constexpr(std::is_integral_v<Length>){
				l = length;
			}
			else{
				l = length();
			}
			/// check length
			if (l == 0){
				/// length irrelevant, do not do anything
				work = false;
			}
			else{
				/// we ha ve valid length
				if(configuration.pre.is_valid()){
					configuration.pre();
				}
				/// shall we really use dma ?
				if(l == 1){
					transfer(tx, rx, l);
				}else{
					rx[0] = transferBlockingSingleByte(tx[0]);
				}
			}
		}
		return work;
	};
}




// template <class DmaChannelRx, class DmaChannelTx>
// static void
// modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::transfer(modm::platform::SpiMaster{{ id }}::SpiTransferTask, modm::platform::SpiMaster{{ id }}::SpiTransferCallback cb, SpiTransferConfiguration configuration)
// {
// 	push({.task = task, .cb = cb, .config = configuration });
// }

template <class DmaChannelRx, class DmaChannelTx>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::push(SpiTansferEntry&& entry)
{
	/// push entry onto queue if not full, remember if this is the first task on queue
	bool instant = queue.empty();
	if(!queue.full()){
		queue.push(entry);
	}
	/// if this is the first task on queue, exec current task immediately
	if(instant){
		exec();
	}
	else{
		/// just do nothing ... 
	}
}

template <class DmaChannelRx, class DmaChannelTx>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::exec()
{
	/// exec the current task from queue if nothing else is going on
	if(!queue.empty() && (dmaTransmitComplete && dmaReceiveComplete)){
		const auto& entry = queue.front();
		/// exec task now
		bool didADmaThing = entry.task();
		/// if task has not done anything, becasue its conditional failed
		/// pretend that we are finished, but skip the post stuff of the given task
		if(!didADmaThing){
			end(true);
		}
	}
}

template <class DmaChannelRx, class DmaChannelTx>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::handleDmaTransferError()
{
	SpiHal{{ id }}::disableInterrupt(SpiBase::Interrupt::TxDmaEnable |
			SpiBase::Interrupt::RxDmaEnable);
	Dma::RxChannel::stop();
	Dma::TxChannel::stop();
	dmaError = true;
}

template <class DmaChannelRx, class DmaChannelTx>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::handleDmaReceiveComplete()
{
	Dma::RxChannel::stop();
	dmaReceiveComplete = true;
	end();
}

template <class DmaChannelRx, class DmaChannelTx>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::handleDmaTransmitComplete()
{
	Dma::TxChannel::stop();
	dmaTransmitComplete = true;
	end();
}


template <class DmaChannelRx, class DmaChannelTx>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::end(bool skipPost)
{
	/// we finished a task thingy
	if(dmaTransmitComplete && dmaReceiveComplete){
		const auto& entry = queue.front();
		/// do we want to skip its post stuff?
		if(!skipPost){
			/// d its post stuff
			if(entry.config.post.is_valid()){
				entry.config.post();
			}
			if(entry.cb.is_valid()){
				entry.cb();
			}
		}
		/// pop the task from queue
		queue.pop();
		/// re trgger ourselfs if necessary
		exec();
	}
}

template <class DmaChannelRx, class DmaChannelTx>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::transfer(const uint8_t *tx,
		uint8_t *rx, std::size_t length)
{
	dmaError = false;
	SpiHal{{ id }}::enableInterrupt(SpiBase::Interrupt::TxDmaEnable | SpiBase::Interrupt::RxDmaEnable);
	if (tx) {
		Dma::TxChannel::setMemoryAddress(uint32_t(tx));
		Dma::TxChannel::setMemoryIncrementMode(true);
	} else {
		Dma::TxChannel::setMemoryAddress(uint32_t(&dmaDummy));
		Dma::TxChannel::setMemoryIncrementMode(false);
	}
	if (rx) {
		Dma::RxChannel::setMemoryAddress(uint32_t(rx));
		Dma::RxChannel::setMemoryIncrementMode(true);
	} else {
		Dma::RxChannel::setMemoryAddress(uint32_t(&dmaDummy));
		Dma::RxChannel::setMemoryIncrementMode(false);
	}

	Dma::RxChannel::setDataLength(length);
	dmaReceiveComplete = false;
	Dma::RxChannel::start();

	Dma::TxChannel::setDataLength(length);
	dmaTransmitComplete = false;
	Dma::TxChannel::start();
}
