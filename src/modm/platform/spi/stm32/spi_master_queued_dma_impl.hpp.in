/*
 * Copyright (c) 2020, Mike Wolfram
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

#ifndef MODM_STM32_SPI_MASTER{{ id }}_QUEUED_DMA_HPP
#	error 	"Don't include this file directly, use 'spi_master_{{ id }}__Queued_Dma.hpp' instead!"
#endif

template <class DmaChannelRx, class DmaChannelTx>
template <class SystemClock, modm::baudrate_t baudrate, modm::percent_t tolerance>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::initialize()
{
	// Configure the DMA channels, then calls SpiMaster{{ id }}::initialzie().
	Dma::RxChannel::configure(DmaBase::DataTransferDirection::PeripheralToMemory,
			DmaBase::MemoryDataSize::Byte, DmaBase::PeripheralDataSize::Byte,
			DmaBase::MemoryIncrementMode::Increment, DmaBase::PeripheralIncrementMode::Fixed,
			DmaBase::Priority::High);
	Dma::RxChannel::setPeripheralAddress(SPI{{ id }}_BASE + 0x0c);
	Dma::RxChannel::setTransferErrorIrqHandler(handleDmaTransferError);
	Dma::RxChannel::setTransferCompleteIrqHandler(handleDmaReceiveComplete);
	Dma::RxChannel::enableInterruptVector();
	Dma::RxChannel::enableInterrupt(DmaBase::InterruptEnable::TransferError |
			DmaBase::InterruptEnable::TransferComplete);
	Dma::RxChannel::template setPeripheralRequest<Dma::RxRequest>();

	Dma::TxChannel::configure(DmaBase::DataTransferDirection::MemoryToPeripheral,
			DmaBase::MemoryDataSize::Byte, DmaBase::PeripheralDataSize::Byte,
			DmaBase::MemoryIncrementMode::Increment, DmaBase::PeripheralIncrementMode::Fixed,
			DmaBase::Priority::High);
	Dma::TxChannel::setPeripheralAddress(SPI{{ id }}_BASE + 0x0c);
	Dma::TxChannel::setTransferErrorIrqHandler(handleDmaTransferError);
	Dma::TxChannel::setTransferCompleteIrqHandler(handleDmaTransmitComplete);
	Dma::TxChannel::enableInterruptVector();
	Dma::TxChannel::enableInterrupt(DmaBase::InterruptEnable::TransferError |
			DmaBase::InterruptEnable::TransferComplete);
	Dma::TxChannel::template setPeripheralRequest<Dma::TxRequest>();

	SpiMaster{{ id }}::initialize<SystemClock, baudrate, tolerance>();

%% if "fifo" in features
	SpiHal{{ id }}::setRxFifoThreshold(SpiHal{{ id }}::RxFifoThreshold::QuarterFull);
%% endif
}

template <class DmaChannelRx, class DmaChannelTx>
uint8_t
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::transferBlockingSingleByte(uint8_t data){
	// disable DMA for single byte transfer
	SpiHal{{ id }}::disableInterrupt(SpiBase::Interrupt::TxDmaEnable | SpiBase::Interrupt::RxDmaEnable);
	// wait for previous transfer to finish
	while (!SpiHal{{ id }}::isTransmitRegisterEmpty()){
		/// ...
	}
	// start transfer by copying data into register
	SpiHal{{ id }}::write(data);
	while(!SpiHal{{ id }}::isReceiveRegisterNotEmpty()){
		/// ...
	}
	SpiHal{{ id }}::read(data);
	return data;
}

template <class DmaChannelRx, class DmaChannelTx>
uint8_t
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::transferBlocking(uint8_t data, modm::SpiTransferConfiguration& configuration)
{
	if(configuration.pre.is_valid()){
		configuration.pre();
	}
	uint8_t read = transferBlockingSingleByte(data);
	if(configuration.post.is_valid()){
		configuration.post();
	}
	return read;
}

template <class DmaChannelRx, class DmaChannelTx>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::transferBlocking(const uint8_t *tx, uint8_t *rx, std::size_t length, modm::SpiTransferConfiguration& configuration){
	if(configuration.pre.is_valid()){
		configuration.pre();
	}
	for(size_t i = 0; i < length; i++){
		uint8_t b = tx[i];
		rx[i] = transferBlockingSingleByte(b);
	}
	if(configuration.post.is_valid()){
		configuration.post();
	}
}

template <class DmaChannelRx, class DmaChannelTx>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::handleDmaTransferError()
{
	SpiHal{{ id }}::disableInterrupt(SpiBase::Interrupt::TxDmaEnable |
			SpiBase::Interrupt::RxDmaEnable);
	Dma::RxChannel::stop();
	Dma::TxChannel::stop();
	dmaError = true;
}

template <class DmaChannelRx, class DmaChannelTx>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::handleDmaReceiveComplete()
{
	MODM_LOG_INFO << "RxComplete" << modm::endl;
	Dma::RxChannel::stop();
	dmaReceiveComplete = true;
	end();
}

template <class DmaChannelRx, class DmaChannelTx>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::handleDmaTransmitComplete()
{
	MODM_LOG_INFO << "TxComplete" << modm::endl;
	Dma::TxChannel::stop();
	dmaTransmitComplete = true;
	end();
}


template <class DmaChannelRx, class DmaChannelTx>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::end(bool skipPost)
{
	/// we finished a task thingy
	if(dmaTransmitComplete && dmaReceiveComplete){
		MODM_LOG_INFO << "End" << modm::endl;
		const auto& entry = queue.back();
		/// do we want to skip its post stuff?
		if(!skipPost){
			/// do its post stuff
			if(entry.step.configuration.post.is_valid()){
				entry.step.configuration.post();
			}
			if(entry.step.cb.is_valid()){
				entry.step.cb();
			}
		}
		/// pop the task from queue
		queue.pop();
		/// re trgger ourselfs if necessary
		exec();
	}
}

template <class DmaChannelRx, class DmaChannelTx>
void
modm::platform::SpiMaster{{ id }}QueuedDma<DmaChannelRx, DmaChannelTx>::transfer(const uint8_t *tx, uint8_t *rx, std::size_t length)
{
	dmaError = false;
	SpiHal{{ id }}::enableInterrupt(SpiBase::Interrupt::TxDmaEnable | SpiBase::Interrupt::RxDmaEnable);
	if (tx) {
		Dma::TxChannel::setMemoryAddress(uint32_t(tx));
		Dma::TxChannel::setMemoryIncrementMode(true);
	} else {
		Dma::TxChannel::setMemoryAddress(uint32_t(&dmaDummy));
		Dma::TxChannel::setMemoryIncrementMode(false);
	}
	if (rx) {
		Dma::RxChannel::setMemoryAddress(uint32_t(rx));
		Dma::RxChannel::setMemoryIncrementMode(true);
	} else {
		Dma::RxChannel::setMemoryAddress(uint32_t(&dmaDummy));
		Dma::RxChannel::setMemoryIncrementMode(false);
	}

	MODM_LOG_INFO << "transfer [length: " << length << "]" << modm::endl; 

	Dma::RxChannel::setDataLength(length);
	dmaReceiveComplete = false;
	Dma::RxChannel::start();

	Dma::TxChannel::setDataLength(length);
	dmaTransmitComplete = false;
	Dma::TxChannel::start();
}
