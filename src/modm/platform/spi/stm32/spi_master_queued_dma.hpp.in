/*
 * Copyright (c) 2020, Mike Wolfram
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

#ifndef MODM_STM32_SPI_MASTER{{ id }}_QUEUED_DMA_HPP
#define MODM_STM32_SPI_MASTER{{ id }}_QUEUED_DMA_HPP

#include <modm/platform/dma/dma.hpp>
#include "spi_master_{{ id }}.hpp"

namespace modm
{

namespace platform
{

/**
 * Serial peripheral interface (SPI{{ id }}) with DMA support.
 *
 * This class uses the DMA controller for sending and receiving data, which
 * greatly reduces the CPU load. Beside passing the DMA channels as template
 * parameters the class can be used in the same way like the SpiMaster{{ id }}.
 *
 * @tparam DmaChannelRX DMA channel for receiving
 * @tparam DmaChannelTX DMA channel for sending
 *
 * @author	Mike Wolfram
 * @ingroup	modm_platform_spi modm_platform_spi_{{id}}
 */

template <class DmaChannelRx, class DmaChannelTx>
class SpiMaster{{ id }}QueuedDma : public SpiMaster{{ id }}
{
private:
	struct SpiTansferEntry{
		modm::SpiTransferTask task;
		modm::SpiTransferCallback cb;
		modm::SpiTransferConfiguration config;
	};
	using SpiTransferTaskQueue = etl::queue<SpiTansferEntry, 64>;
	static constexpr size_t SPI_DATA_BUFFER_LENGTH = 64;
	static constexpr size_t SPI_DATA_BUFFER_COUNT = 32;
	using SpiDataBuffer = std::array<uint8_t,SPI_DATA_BUFFER_LENGTH>;
	using SpiDataQueue = std::array<SpiDataBuffer, SPI_DATA_BUFFER_COUNT>;

	struct Dma {
		using RxChannel = typename DmaChannelRx::template RequestMapping<
				Peripheral::Spi{{ id }}, DmaBase::Signal::Rx>::Channel;
		using TxChannel = typename DmaChannelTx::template RequestMapping<
				Peripheral::Spi{{ id }}, DmaBase::Signal::Tx>::Channel;
		static constexpr DmaBase::Request RxRequest = DmaChannelRx::template RequestMapping<
				Peripheral::Spi{{ id }}, DmaBase::Signal::Rx>::Request;
		static constexpr DmaBase::Request TxRequest = DmaChannelTx::template RequestMapping<
				Peripheral::Spi{{ id }}, DmaBase::Signal::Tx>::Request;
	};

public:
	/**
	 * Initialize DMA and SPI{{ id }}
	 */
	template <class SystemClock, baudrate_t baudrate, percent_t tolerance=pct(5)>
	static void
	initialize();

	static uint8_t
	transferBlocking(uint8_t data, modm::SpiTransferConfiguration& configuration = modm::SpiTransferConfiguration{});

	static void
	transferBlocking(const uint8_t *tx, uint8_t *rx, std::size_t length, modm::SpiTransferConfiguration& configuration = modm::SpiTransferConfiguration{});

	static void
	transferBegin(const uint8_t *tx, uint8_t *rx, std::size_t length, modm::SpiTransferCallback cb, modm::SpiTransferConfiguration& configuration = modm::SpiTransferConfiguration{});

	template <typename Length>
	static void
	transferNext(const uint8_t *tx, uint8_t *rx, Length length, modm::SpiTransferCallback cb, modm::SpiTransferConfiguration& configuration = modm::SpiTransferConfiguration{});

	template <typename Length>
	static void
	transferNext(const uint8_t *tx, uint8_t *rx, Length length, modm::SpiTransferCallback cb, modm::SpiTransferConditional condition, modm::SpiTransferConfiguration& configuration = modm::SpiTransferConfiguration{});

	// static modm::ResumableResult<void>
	// transfer(SpiTransferTask, SpiTransferCallback cb, SpiTransferConfiguration configuration = SpiTransferConfiguration{});

	// template <typename... Steps>
	// static constexpr void pipeline(SpiTransferStep step, Steps... rest){
	// 	transferBegin(step.tx, step.rx, step.cb, step.configuration);
	// 	std::apply([](auto&&... s){
	// 		((transferNext(s.tx, s.rx, s.length, s.cb, s.condition, s.configuration)), ...);
	// 	}, std::tie(rest...));
	// };

private:
	static uint8_t
	transferBlockingSingleByte(uint8_t b);

	static void 
	transfer(const uint8_t *tx, uint8_t *rx, std::size_t length);

	template <typename Length>
	modm::SpiTransferTask createTask(const uint8_t *tx, uint8_t *rx, Length length, modm::SpiTransferCallback cb, 
		modm::SpiTransferConditional condition, modm::SpiTransferConfiguration& configuration);

private:
	static void
	handleDmaTransferError();
	static void
	handleDmaReceiveComplete();
	static void
	handleDmaTransmitComplete();

	static void push(SpiTansferEntry&& entry);
	static void exec();
	static void end(bool skipPost = false);


	static inline bool dmaError { false };
	static inline bool dmaTransmitComplete { false };
	static inline bool dmaReceiveComplete { false };

	// needed for transfers where no RX or TX buffers are given
	static inline uint8_t dmaDummy { 0 };

	static inline SpiTransferTaskQueue queue;
	static inline SpiDataQueue buffers;
	static inline size_t nextBuffer = 0;
};

} // namespace platform

} // namespace modm

#include "spi_master_{{ id }}_queued_dma_impl.hpp"

#endif // MODM_STM32_SPI_MASTER{{ id }}_QUEUED_DMA_HPP
